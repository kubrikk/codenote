---
layout: post
title: "Бинарный поиск"
author: "kubrikk"
tags: "Бинарный-поиск"
permalink: binary-search
katex: True
---

## Левосторонний бинарный поиск (поиск первого вхождения)

___Левосторонний бинарный поиск___ (*сокр.* $$\textnormal{LBS}$$) — это вариант классического двоичного поиска, который находит первое вхождение заданного значения $$\textit{key}$$ в отсортированном массиве $$arr[size]$$. 

Иными словами _левосторонний бинарный поиск_ находодит $$\min \{i \ \vert \ arr[i] = key \}$$. 


При реализации левостороннего (как и правостороннего) бинарного поиска очень удобно брать в качестве рассматриваемого диапазона полуинтервал. Т.е. вместо того, чтобы рассматривать отрезок $$[left; right]$$ мы можем рассматривать полуинтервал $$(left; right]$$ (в случае с левосторонним поиском), что позволяет нам получить некоторый радя плюсов: 
1. Использование полуинтервалов позволяет избежать путаницы с включением или исключением границ. 
2. Полуинтервалы гарантируют, что цикл завершится, и не возникнет бесконечного зацикливания.


<img src="{{site.baseurl}}/assets/images/binary-search/leftside-binary-search.png" class="img-responsive">
<em>Рис. 1. Левосторонний бинарный поиск (концептуально)</em>





### Реализации

Реализацию левогостороннего бинарного поиска $$\textnormal{leftside\_binary\_search}$$ можно изобразить следующим образом:

{% highlight cpp  linenos %}
/**
 * Реализация левостороннего бинарного поиска. 
 */
int leftside_binary_search(int* arr, int size, int key) {
    int left  = -1;
    int right = size - 1;

    while (right - left > 1) {
        int middle = (right + left) / 2;
        if (arr[middle] < key) { left = middle; }
        else { right = middle; }
    }

    return arr[right] == key ? right : -1;
}
{% endhighlight %}


Данный программный код представляет собой реализацию алгоритма левостононнено бинарного поиска, который ищет первое вхождение элемента $$key$$ в отсортированном массиве $$arr$$. В данном случае можно сказать, что функция (*сокр.* $$\textnormal{LBS}$$) возвращает либо индекс первого вхождения элемента, равного $$key$$, или $$-1$$, если такого элемента нет в массиве:

$$
\textnormal{LBS}(arr, size, key) =
\begin{cases}
    \min \{i \ | \ arr[i] = key \}, & \exist \ i: arr[i] = key; \\
    -1, & otherwise.
\end{cases}
$$

Изначально указатели на границы получинтервала установлены следующим образом:
1. `right = size - 1` — правая граница полуинтервала; при завершении алгоритма будет указывать на *больший либо равный* $$key$$ элемент.
2. `left = -1` — левая граница полуинтервала, которая является выколотой; это сделано для того, чтобы $$right$$ потенциально имел возможность указывать на $$0$$-ой элемент массива.

Цикл $$while$$ выполняется до тех пор, пока разница между right и left больше 1, иными словами поиск продолжается до тех пор, пока в полуинтевале не останется только один элемент.


### Пример

Пусть перед нами стоит задача следующего содержания: необходимо найти индекс первого вхождения числа $$33$$ в массиве $$arr$$:

{% highlight cpp %}
arr = { 5, 7, 13, 13, 23, 32, 33, 33, 33, 42, 43 };
{% endhighlight %}


<img src="{{site.baseurl}}/assets/images/binary-search/leftside-binary-search_2.png" class="img-responsive">
<em>Рис. 2. Пример левостороннего бинарного поиска</em>

__Асимптотическая оценка работы функции__:
* ___Пространственная оценка___ работы $$M_{\texttt{LBS}}(n) \in O(1)$$.
* ___Временная оценка___ работы $$T_{\texttt{LBS}}(n) \in O(\log n)$$.

---
